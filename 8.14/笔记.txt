对象: 列表,元组,字典.

数据的存储: 内存

磁盘: 存储文件(静态文件)

内存: 存储正在运行的应用程序里面产生的数据

id(数据): 查看数据的内存地址

内存地址: 数据在内存当中的地址,一般通过内存地址找到该数据 (十六进制数据)

二进制: 010101
八进制: 0-7
十进制(现实生活中的数值):0 - 9
十六进制: 0-9 a-f

普通数据的存储: 数字,布尔,字符串 (直接在内存当中开辟一片空间进行存储)



对象的存储: 列表,元组,字典. (会在内存当中开辟两片空间,一片用来存储变量,另一片用来存储对象)

a = [10,20,30] : 将列表的内存地址赋值给a

a变量对列表有一个指向关系: 对象的引用 (a就代表该列表了)

参数进行传递的时候,分为两种

值传递: 数字或者字符串

引用传递: 对象

浅复制(拷贝): 只拷贝对象的第一层,如果对象里面还有对象的话(对象的嵌套),不会拷贝里面的对象  对象名.copy()

深复制(拷贝): 拷贝每一层  (拷贝以后的内容互不影响)

import copy

result = copy.deepcopy(要拷贝的对象)


为什么要拷贝???  

如果要让两个列表一致,拷贝的速度是最快

a = [10,20,30]
# 要有列表b和a一样
b = a
# 引用的问题
b[0] = 100

b = []
for i in a:
	b.append(i)


== : 判断两个数据是否相等 (比较的是内容)

is : 比较的是内存地址是否一样 (a is b)

python的解释器: CPython  (windows+r --> cmd (终端) --> python)

pycharm: python的辅助工具(方便快速开发程序)

小数据池: 简单的数据类型,值如果相同,那么会在内存当中开辟相同的空间去存储数据
1.数字类型: -5 ~ 256 之间的数字

2.没有特殊字符的字符串

3.单个字符 * 20以内,超出20,内存地址不一样

列表生成式: 列表推导式  快速生成列表,可以对列表里面的元素进行一些处理

格式: [列表中的元素 for 变量 in 序列]

和if使用: [列表中的元素 for 变量 in 序列 if 条件]

和if else使用: [列表中的元素 if 条件 else 列表中的元素 for 变量 in 序列]

嵌套: [列表中的元素 for 变量1 in 序列 for 变量2 in 序列]

sorted(列表,key,reverse): 进行排序

key: 要求是函数 (该函数的返回值就是按照它进行排序的)

有名字的函数
def 函数名(形参):
	函数体
	return 返回值

函数名: 可以代替一个函数 (该函数的内存地址)


a: '1012312321321213'
b: '11'


字符串的比较: 从左往右进行比较,一位一位比,如果有个数值要大,那么该数据就是大的

sorted使用场景: 列表里面是一个个字典的时候进行排序

filter(function,列表): 从列表中筛选数据

筛选条件在function的返回值里面

匿名函数: 实现简单的功能

格式: lambda 形参:返回值

结合if..else使用

格式: lambda 形参:条件成立的返回值 if 条件 else 条件不成的时候的返回值


练习:
a = [
    {'name': 'aa','age': 80},
    {'name': 'zs1','age': 30},
    {'name': 'aasd32','age': 50},
    {'name': 'zs12','age': 10},
    {'name': 'zsaqew','age': 20},
    {'name': 'zs213','age': 100},
    {'name': 'zswer','age': 3}
]
1.使用def的函数的方式,取出大于20的数据,并且从小到大排序

2.使用匿名函数的方式,取出名字带有字母a的数据,并且从小到大排序


递归函数: 函数调用自己

递归函数的思想: 把规模大的,比较难解决的问题,拆分成规模小的问题,再把规模小的问题再拆分成规模更小的问题...一层层拆分,拆分到一定的程度,变为非常非常非常小的问题,那问题最后就解决了

10排 (你的位置)
9排
8排
7排
6排
5排
4排
3排
2排
1排  (作业本)

递归函数不能一直让他调用自己,最终会报错

递归深度: 该函数能自己调用几次自己  (1000)

设置递归深度:
import sys (系统的模块)
sys.setrecursionlimit(5000) : 不会直接到5000次,只会比1000次大一些

递归函数,一定要有退出条件(return),不退出程序会崩溃



递归能解决的问题:
100 + 99 + 98 + 97 + ...+ 1

100 + 99的和 

100 + 99的和 + 98的和 97的和 ... 3的和 2的和 1的和


递归注意的点:
1.一定是自己调用自己
2.一定要有退出条件

练习: 设计一个递归函数,功能: 求n的阶乘

f(5) : 5 * f(4)
f(4):  4 * f(3)


f(5): 120
f(4): 24

实现斐波那契数列(黄金分割数列,兔子数列): 1、1、2、3、5、8、13、21、34..

先购买一对兔子,假设兔子永远不死,两个月就长大,并且能生一对新兔子,长大后,每个月都能生一对兔子

f(1): 1
f(2): 1
f(3): 2

f(20): ????

公园里有一只猴子和一堆桃子，猴子每天吃掉桃子总数的一半，把剩下一半中扔掉一个坏的。到第七天的时候，猴子睁开眼发现只剩下一个桃子。问公园里刚开始有多少个桃子？

f(7): 1

f(6): 4   (f(7) + 1) * 2

f(5): 10  (f(6) + 1) * 2
..

f(1): ??? 

总结: 

数据类型: 数字,字符串(方法),列表(方法),字典(设置,获取),元组,集合

数据类型的转换:

序列

函数

重点: 提升逻辑思维能力




